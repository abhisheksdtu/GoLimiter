package main

import (
	"context"
	"fmt"
	"net/http"

	"golimiter/internal/limiter"
	"golimiter/internal/middleware"
	"golimiter/pkg/api"
	"golimiter/pkg/config"
	"golimiter/pkg/logging"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"go.uber.org/zap"

	_ "golimiter/docs" // docs is generated by Swag CLI
)

// @title GoLimiter API
// @version 1.0
// @description This is a distributed rate limiter microservice.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /
func main() {
	// Load config
	cfg := config.Load()

	// Set up logger
	logger, err := logging.NewLogger()
	if err != nil {
		panic(fmt.Sprintf("failed to create logger: %v", err))
	}
	defer logger.Sync()

	// Set up storage
	var storage limiter.Storage
	if cfg.RedisAddr != "" {
		logger.Info("Using Redis storage")
		storage = limiter.NewRedisStorage(cfg.RedisAddr, cfg.RedisPassword, cfg.RedisDB)
	} else {
		logger.Info("Using in-memory storage")
		storage = limiter.NewMemoryStorage()
	}

	// Set up rate limiter
	tokenBucket := limiter.NewTokenBucket(storage, cfg.RateLimit, cfg.Burst)
	rateLimiter := limiter.NewRateLimiter(tokenBucket)

	// Set up Gin router
	router := gin.Default()
	router.Use(middleware.PrometheusMiddleware())

	// Health check
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	// Metrics and API
	router.GET("/metrics", middleware.MetricsHandler())
	router.POST("/check-limit", checkLimitHandler(rateLimiter, logger))

	// Swagger route
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Start server
	addr := fmt.Sprintf(":%s", cfg.ServerPort)
	logger.Info("Starting server", zap.String("address", addr))
	if err := router.Run(addr); err != nil {
		logger.Fatal("Failed to start server", zap.Error(err))
	}
}

// checkLimitHandler handles the /check-limit endpoint.
// @Summary Check if a request is within the rate limit
// @Description Checks if a request for a given key is allowed based on the token bucket algorithm.
// @Accept  json
// @Produce  json
// @Param   request body api.CheckLimitRequest true "Check Limit Request"
// @Success 200 {object} api.CheckLimitResponse
// @Failure 400 {object} api.ErrorResponse
// @Failure 500 {object} api.ErrorResponse
// @Router /check-limit [post]
func checkLimitHandler(rateLimiter *limiter.RateLimiter, logger *zap.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		var req api.CheckLimitRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			logger.Error("Failed to bind JSON", zap.Error(err))
			c.JSON(http.StatusBadRequest, api.ErrorResponse{Message: "invalid request"})
			return
		}

		allowed, err := rateLimiter.Allow(context.Background(), req.Key)
		if err != nil {
			logger.Error("Failed to check rate limit", zap.Error(err))
			c.JSON(http.StatusInternalServerError, api.ErrorResponse{Message: "internal server error"})
			return
		}

		middleware.RecordMetrics(allowed)

		c.JSON(http.StatusOK, api.CheckLimitResponse{Allowed: allowed})
	}
}
